= Walruz: Simple but Powerful Authorization Framework

== Basic and Terminology

Walruz facilitates the separation between the authorization process on the business logic and the actions executed after the validation of the authorizations. To understand how it works, we will follow the following terminology:

[*Subject*] Object that is going to be managed (Profile, Posts).
[*Actor*] Entity that wants to perform an action on a _subject_ (User, Admin).
[*Policy*] A set of rules that tells if the _actor_ can perform the desired action on the _subject_.

== Walruz Architecture 

Walruz provides modules and classes that help on the implementation of the concepts given previously, this are:
  
[<b>+Walruz::Subject+</b>]
  Module that provides the interface to associate policies to an action in the _subject_.
  
[<b>+Walruz::Actor+</b>]
  Module that provides the interface to perform queries to validate if an action can be done between the
  _actor_ and the _subject_.
    
[<b>+Walruz::Policy+</b>]
  Class that provides the interface to implement authorization logic.

== Subjects specify which policies are related to which actions

Subject classes may specify a set of actions that can be performed to them using the +check_authorization+ method

  class User
    include Walruz::Subject
    
    check_authorization :read => UserReadPolicy,
                        :update => UserUpdatePolicy
  end

If there is just one _policy_ to every possible action performed to the _subject_, you may specify the :default action, or just specify the Policy class.

Example:

  class User
    include Walruz::Subject
  
    check_authorization UserPolicy
  end

or

  class User
    include Walruz::Subject
  
    check_authorization :default => UserPolicy
  end
  
You can also specify other flags with the default flag.

  class User
    include Walruz::Subject

    check_authorization :read => UserReadPolicy,
                        :update => UserUpdatePolicy,
                        :default => UserPolicy
  end

== Actors verify if they are able to perform an action on a subject

Actor classes can use several methods to check if the _actor_ instance can perform the given action on a _subject_. This are:

[<b>+can?(action, subject)+</b>] Returns boolean that says if the _actor_ can execute or not the action on the _subject_.

[<b>+authorize(action, subject)+</b>] In case the _actor_ can execute the action on the _subject_, it returns the parameters hash from the _policy_, otherwise it will raise a +Walruz::NotAuthorized+.

[<b>+satisfies?(policy_label, subject)+</b>] It behaves just like the +can?+ method, but instead of giving an action to be executed to the _subject_, it receives a _policy_ label.

In case the given action is not assigned to any _policy_, a default Policy will be executed (if given), if no default _policy_ is given then a +Walruz::ActionNotFound+ exception will be raised.

Examples:
  
  current_user.can?(:read, friends_profile)      #=> true
  current_user.satisfies?(:actor_is_admin, nil)  #=> false
  current_user.satisfies?(:actor_is_admin, nil)  #=> nil
  current_user.authorize(:read, friends_profile) #=> Hash
  current_user.authorize!(:read, other_person_profile) # => raises Walruz::NotAuthorized 

== Implementing Policies

To implement a _policy_, it is necessary to inherit from the Walruz::Policy class. This class provides a method called +authorized?+ that return either a Boolean, or an Array of two items, the first one being a Boolean, and the second being a Hash of parameters returned from the Policy.

Every Policy Class also has a label associated to it, by default the label will be the name of the class in underscore case; if you want to have a custom label for a Policy Class, you can invoke the +set_policy_label+ method on the class context and specify the label that you want for it. This label is used on the +satisfies?+ method.

Examples:
  
  class ActorIsAdmin < Walruz::Policy
    set_policy_label :is_admin
  
    def authorized?(actor, _)
      actor.is_admin?
    end
  
  end
  
  class UserIsFriend < Walruz::Policy
  
    def authorized?(current_user, friend)
      friendship = Friendship.first(:conditions => { :friend_id => current_user.id, :owner_id => friend.id})
      if !friendship.nil?
        [true, {
          :friendship => friendship
        }]
      else
        false
      end
    end
  
  end


== Composing basic policies to create complex ones

Sometimes policies can turn really messy, specially when you have a complex business model. The good news is that normally this complex policies are a composition of more simple policies (e.g. ActorCanSeeUserPictures). Instead of creating this new classes that replicates the same logic of basic policies, we could merge them together in the following way:

  ActorCanSeeUserPictures = Walruz::Utils.all(UserIsFriend, UserAllowsDisclosureOfPictures)

There is also the utility methods +any+ and +not+, to create combinations of policies. 

If your _policy_ returns a parameters hash, and you are using the +all+ method, the parameters of each _policy_ will be merged together, if you are using the +any+ method, the parameters of the first _policy_ that returns true will be returned.

One other thing that the utility methods does for you is that it leaves its track on the returned _policy_ parameters, when you invoke a composite _policy_, every _policy_ will leave in the parameters hash the policy_label with a question mark at the end, that way you can know which policies were successful or not. 

Example:
  
  class ActorIsAdmin < Walruz::Policy 
    set_policy_label :is_admin

    def authorized?(actor, _)
      actor.is_admin?
    end

  end
  
  class ActorIsSubject < Walruz::Policy
    def authorized?(actor, subject); actor == subject; end
  end
  
  UserReadPolicy = any(ActorIsSubject, ActorIsAdmin)
  
  class User < AbstractORM
    include Walruz::Subject
    
    check_authorizations :read => UserReadPolicy
  end
  
  class UsersController < Framework::Controller
    def show
      policy_params = current_user.authorize(:read, other_user)
      if policy_params[:actor_is_subject?]
        # do logic of the user interacting with herself
      elsif policy_params[:is_admin?]
        # do logic of the admin user interacting with other user
      else
        # do other logic here...
      end
    end
  end

== Dependencies between Policies

Sometimes you would like to have a Policy that strictly depends in other policies, on the previous example +UserAllowsDisclosureOfPictures+ could have a dependency that says that only the User allows the disclosure of pictures if and only if there is a friend relationship, so we could re-implement this _policy_ as:

Example:

  class UserAllowsDisclosureOfPictures < Walruz::Policy
    depends_on UserIsFriend
    # ...
  end

Suppose you need the parameters returned by the previous Policy, you can have them with the +params+ method.

Example:

  class UserAllowsDisclosureOfPictures < Walruz::Policy
    depends_on UserIsFriend
    
    def authorized?(_, _)
      params[:friendship].allows_disclosure_of_images?
    end
    
  end
  
== Policy combinators

Sometimes you would like to execute policies that are not directly related to a _subject_, but to the association of a _subject_. Given the example above of the friendship relationship and the disclosure of pictures, sometimes you would like to check if a user can see a picture directly on the picture model.

Suppose we have the following model in our system:

  class Picture < AbstractORM
    belongs_to :owner
  end

and we would like to check if the current_user can see (read) the picture using:

  current_user.can?(:read, picture_instance)
  
If you may recall, we already implemented the logic that checks that authorization in UserAllowsDisclosureOfPictures, but that _policy_ only works when the _subject_ is of class User; given that you have a _subject_ of class Picture you can not re-use this _policy_.

You could solve this issue doing the following:

  class PictureReadPolicy < Walruz::Policy
    
    def authorized?(user, image)
      user.satisfies?(UserAllowsDisclosureOfPictures, image.owner)
    end
    
  end

But as you may see, we are just creating new policies to handle old ones, we are not combining the policies effectively. To avoid this caveat, you can use the +PolicyClass.for_subject+ method:

  PictureReadPolicy = UserAllowsDisclosureOfPictures.for_subject(:owner)
  
  class Picture < AbstractORM
    include Walruz::Subject
    belongs_to :owner
    
    check_authorizations :read => PictureReadPolicy
  end
  
The parameter of +but_for+ is the name of the _subject's_ method that will return a new _subject_, this new _subject_ is then passed through the _policy_. Pretty neat eh?

== Returning custom errors

Suppose you want to add an error to the authorization failure that is a more descriptive, you can do so on the +authorized?+ method passing a hash with a :error_message key on the false return. If you use the +can!+ method on the _actor_ model, this will become the +Walruz::NotAuthorized+ error message.

Example:
  
  class SomePolicy < Walruz::Policy
  
    def authorized?(actor, subject)
      # some complex logic here
      return [false, {
        :error_message => 'More descriptive error message'
      }]
    end
  end


== Conventions

You'll notice that once you start implementing policies for your system, you'll be lost soon enough asking yourself which type of _subject_ a Policy receives; to avoid such confusions, we suggest that you apply the following rules:

- The first name of the _policy_ should be the Subject class (e.g. UserIsFriend)
- If the _policy_ only applies to the _actor_, the _policy_ class name should start with the Actor word (e.g. ActorIsAdmin)
- You should always have the compositions of policies in just one place in your library folder (e.g. in policies.rb file).
- The result of _policy_ compositions should finish with the word Policy (e.g +UserDeletePolicy = any(ActorIsSubject, ActorIsAdmin+))
- Use +PolicyClass.but_for+ when you are combining the PolicyClass with other policies, if you are not doing this, consider checking authorizations on parents of the _subject_ instead of the _subject_ (e.g. current_user.can?(:see_pictures_of, picture.owner))

If you follow this rules, it will be much easier for you to merge policies together in an efficient way.

== Rails Integration

See "walruz-rails":http://walruz-rails.rubyforge.com gem

== More examples

You may check the project in the examples/ directory for more info; on the rails project, take a look on the spec/models/beatle_spec.rb file, it's really illustrating.

== Copyright

Copyright (c) 2009 Roman Gonzalez <romanandreg@gmail.com>

Copyright (c) 2009 Noomii inc. <http://www.noomii.com>

All rights reserved.
